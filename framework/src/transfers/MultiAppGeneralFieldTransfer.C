//* This file is part of the MOOSE framework
//* https://www.mooseframework.org
//*
//* All rights reserved, see COPYRIGHT for full restrictions
//* https://github.com/idaholab/moose/blob/master/COPYRIGHT
//*
//* Licensed under LGPL 2.1, please see LICENSE for details
//* https://www.gnu.org/licenses/lgpl-2.1.html

#include "MultiAppGeneralFieldTransfer.h"

// MOOSE includes
#include "DisplacedProblem.h"
#include "FEProblem.h"
#include "MooseMesh.h"
#include "MooseTypes.h"
#include "MooseVariableFE.h"

#include "libmesh/generic_projector.h"
#include "libmesh/meshfree_interpolation.h"
#include "libmesh/system.h"
#include "libmesh/mesh_function.h"
#include "libmesh/mesh_tools.h"
#include "libmesh/parallel_algebra.h" // for communicator send and receive stuff

// TIMPI includes
#include "timpi/communicator.h"
#include "timpi/parallel_sync.h"


// Anonymous namespace for functors to use with GenericProjector.
namespace {

  // We need two functors that record point (value and gradient,
  // respectively) requests, so we know what queries we need to make
  // to other processors

  /**
   * Value request recording base class
   */
  template <typename Output>
  class RecordRequests {
    protected:
      typedef typename TensorTools::MakeBaseNumber<Output>::type DofValueType;

    public:
      typedef typename TensorTools::MakeReal<Output>::type RealType;
      typedef DofValueType ValuePushType;
      typedef Output FunctorValue;

      RecordRequests() {}

      RecordRequests(RecordRequests & primary) : _primary(&primary) {}

      ~RecordRequests() {
        if (_primary)
          {
            Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);
            _primary->_points_requested.insert
              (_primary->_points_requested.end(),
	       _points_requested.begin(), _points_requested.end());
          }
      }

      void init_context (FEMContext &) {}

      Output eval_at_node (const FEMContext &,
                           unsigned int libmesh_dbg_var(i),
                           unsigned int /*elem_dim*/,
                           const Node & n,
                           bool /*extra_hanging_dofs*/,
                           const Real /*time*/)
      {
        libmesh_assert_not_equal_to(i,0);
        _points_requested.push_back(n);
        return 0;
      }

      Output eval_at_point (const FEMContext &,
                            unsigned int libmesh_dbg_var(i),
                            const Point & n,
                            const Real /*time*/,
                            bool /*skip_context_check*/)
      {
        libmesh_assert_not_equal_to(i,0);
        _points_requested.push_back(n);
        return 0;
      }

    bool is_grid_projection() { return false; }

    void eval_mixed_derivatives (const FEMContext & /*c*/,
                                 unsigned int /*i*/,
                                 unsigned int /*dim*/,
                                 const Node & /*n*/,
                                 std::vector<Output> & /*derivs*/)
    { libmesh_error(); } // this is only for grid projections

    void eval_old_dofs (const Elem &,
                        unsigned int,
                        unsigned int,
                        std::vector<dof_id_type> &,
                        std::vector<Output> &)
    { libmesh_error(); }

    void eval_old_dofs (const Elem &,
                        const FEType &,
                        unsigned int,
                        unsigned int,
                        std::vector<dof_id_type> &,
                        std::vector<Output> &)
    { libmesh_error(); }

    std::vector<Point> & points_requested() { return _points_requested; }

    private:
      std::vector<Point> _points_requested;

      RecordRequests * _primary = nullptr;
  };


  // We need a null action functor to use
  // with them (because we won't be ready to set any values at that
  // point)
  template <typename Val>
  class NullAction
  {
  public:
    typedef Val InsertInput;

    NullAction() {}

    void insert(dof_id_type, Val) {}

    void insert(const std::vector<dof_id_type> &,
                const DenseVector<Val> &) {}
  };


  // We need two functors that respond to point (value and gradient,
  // respectively) requests based on the cached values of queries answered by
  // other processors.

  /**
   * Value request response base class
   */
  template <typename Output>
  class CachedData {
    protected:
      typedef typename TensorTools::MakeBaseNumber<Output>::type DofValueType;

    public:
      typedef std::unordered_map<Point, Output, MultiAppGeneralFieldTransfer::hash_point> Cache;

      typedef typename TensorTools::MakeReal<Output>::type RealType;
      typedef DofValueType ValuePushType;
      typedef Output FunctorValue;

      CachedData(const Cache & cache) : _cache(cache) {}

      CachedData(const CachedData & primary) : _cache(primary._cache) {}

      void init_context (FEMContext &) {}

      Output eval_at_node (const FEMContext &,
                           unsigned int i,
                           unsigned int /*elem_dim*/,
                           const Node & n,
                           bool /*extra_hanging_dofs*/,
                           const Real /*time*/)
      { return libmesh_map_find(_cache, n); }

      Output eval_at_point (const FEMContext &,
                            unsigned int i,
                            const Point & n,
                            const Real /*time*/,
                            bool /*skip_context_check*/)
      { return libmesh_map_find(_cache, n); }

    bool is_grid_projection() { return false; }

    void eval_mixed_derivatives (const FEMContext & /*c*/,
                                 unsigned int /*i*/,
                                 unsigned int /*dim*/,
                                 const Node & /*n*/,
                                 std::vector<Output> & /*derivs*/)
    { libmesh_error(); } // this is only for grid projections

    void eval_old_dofs (const Elem &,
                        unsigned int,
                        unsigned int,
                        std::vector<dof_id_type> &,
                        std::vector<Output> &)
    { libmesh_error(); }

    void eval_old_dofs (const Elem &,
                        const FEType &,
                        unsigned int,
                        unsigned int,
                        std::vector<dof_id_type> &,
                        std::vector<Output> &)
    { libmesh_error(); }

    private:
      const Cache & _cache;
  };



}


registerMooseObject("MooseApp", MultiAppGeneralFieldTransfer);

InputParameters
MultiAppGeneralFieldTransfer::validParams()
{
  InputParameters params = MultiAppConservativeTransfer::validParams();
  params.addClassDescription(
      "Transfers field data at the MultiApp position using solution the finite element function "
      "from the master application, via a 'libMesh::MeshFunction' object.");

  params.addParam<bool>(
      "error_on_miss",
      false,
      "Whether or not to error in the case that a target point is not found in the source domain.");

  params.addParam<Real>("bbox_tol", 0.1, "How much want to relax bounding boxes");

  params.addParam<std::vector<SubdomainName>>(
      "to_blocks", "The blocks we are transferring to (if not specified, whole domain is used).");

  params.addParam<std::vector<SubdomainName>>(
      "from_blocks",
      "The blocks we are transferring from (if not specified, whole domain is used).");

  return params;
}

MultiAppGeneralFieldTransfer::MultiAppGeneralFieldTransfer(const InputParameters & parameters)
  : MultiAppConservativeTransfer(parameters),
    _error_on_miss(getParam<bool>("error_on_miss")),
    _bbox_tol(getParam<Real>("bbox_tol"))
{
  if (_to_var_names.size() == _from_var_names.size())
    _var_size = _to_var_names.size();
  else
    paramError("variable", "The number of variables to transfer to and from should be equal");
}

void
MultiAppGeneralFieldTransfer::execute()
{
  _console << "Beginning GeneralFieldTransfer " << name() << std::endl;

  getAppInfo();

  // loop over the vector of variables and make the transfer one by one
  for (unsigned int i = 0; i < _var_size; ++i)
    transferVariable(i);

  _console << "Finished GeneralFieldTransfer " << name() << std::endl;

  postExecute();
}

void
MultiAppGeneralFieldTransfer::transferVariable(unsigned int i)
{
  mooseAssert(i < _var_size, "The variable of index " << i << " does not exist");

  // Get the bounding boxes for the "from" domains.
  // Clean up _bboxes
  _bboxes.clear();
  _bboxes = getFromBoundingBoxes();

  // Expand bounding boxes. Some right points might be excluded
  // without an expansion
  for (auto & box : _bboxes)
  {
    auto width = box.second - box.first;
    box.second += width * _bbox_tol;
    box.first -= width * _bbox_tol;
  }

  // Figure out how many "from" domains each processor owns.
  // Clean up _froms_per_proc
  _froms_per_proc.clear();
  _froms_per_proc = getFromsPerProc();

  // Find outgoing target points
  // We need to know what points we need to send which processors
  // One processor will receive many points from many processors
  // One point may go to different processors
  ProcessorToPointVec outgoing_points;
  extractOutgoingPoints(_to_var_names[i], outgoing_points);

  // Get the local bounding boxes for current processor.
  // There could be more than one box because of the number of local apps
  // can be larger than one
  std::vector<BoundingBox> local_bboxes;
  extractLocalFromBoundingBoxes(local_bboxes);

  // Setup the local mesh functions.
  std::vector<std::shared_ptr<MeshFunction>> local_meshfuns;
  buildMeshFunctions(_from_var_names[i], local_meshfuns);

  // Fill values and app ids for incoming points
  // We are responsible to compute values for these incoming points
  auto gather_functor =
      [this, &local_bboxes, &local_meshfuns](processor_id_type /*pid*/,
                                             const std::vector<Point> & incoming_points,
                                             std::vector<Real> & outgoing_vals) {
        outgoing_vals.resize(incoming_points.size(), OutOfMeshValue);
        // Evaluate interpolation values for these incoming points
        evaluateInterpValues(local_bboxes, local_meshfuns, incoming_points, outgoing_vals);
      };

  DofobjectToInterpValVec dofobject_to_valsvec(_to_problems.size());
  InterpCaches interp_caches(_to_problems.size());

  // Copy data out to incoming_vals_ids
  auto action_functor =
      [this, &i, &dofobject_to_valsvec, &interp_caches]
      (processor_id_type pid,
       const std::vector<Point> & my_outgoing_points,
       const std::vector<Real> & incoming_vals) {
        auto & pointInfoVec = _processor_to_pointInfoVec[pid];

        // Cache interpolation values for each dof object
        cacheIncomingInterpVals(
            pid, _to_var_names[i], pointInfoVec, my_outgoing_points,
            incoming_vals, dofobject_to_valsvec, interp_caches);
      };

  // We assume incoming_vals_ids is ordered in the same way as outgoing_points
  // Hopefully, pull_parallel_vector_data will not mess up this
  const Real * ex = nullptr;
  libMesh::Parallel::pull_parallel_vector_data(
      comm(), outgoing_points, gather_functor, action_functor, ex);

  // Set cached valeus into solution vector
  setSolutionVectorValues(_to_var_names[i], dofobject_to_valsvec, interp_caches);
}

void
MultiAppGeneralFieldTransfer::locatePointReceivers(const Point point,
                                                   std::vector<processor_id_type> & processors)
{
  // Check which processors include this point
  // One point might have more than one points
  bool found = false;
  unsigned int from0 = 0;
  for (processor_id_type i_proc = 0; i_proc < n_processors();
       from0 += _froms_per_proc[i_proc], ++i_proc)
    for (unsigned int i_from = from0; i_from < from0 + _froms_per_proc[i_proc]; ++i_from)
      // We will not break here because we want to send a point to all possible source domains
      if (_bboxes[i_from].contains_point(point))
      {
        processors.push_back(i_proc);
        found = true;
      }

  // Error out if we could not find this point when ask us to do so
  if (!found && _error_on_miss)
    mooseError("Cannot locate point ", point, " \n ", "mismatched meshes are used");
}

void
MultiAppGeneralFieldTransfer::cacheOutgoingPointInfor(const Point point,
                                                      const dof_id_type dof_object_id,
                                                      const unsigned int problem_id,
                                                      ProcessorToPointVec & outgoing_points)
{
  std::vector<processor_id_type> processors;
  // Try to find which processors
  processors.clear();
  locatePointReceivers(point, processors);

  // We need to send these data to these processors
  for (auto pid : processors)
  {
    outgoing_points[pid].push_back(point);
    // Store point information
    // We can use these information when insert values to solution vector
    PointInfo pointinfo;
    pointinfo.problem_id = problem_id;
    pointinfo.dof_object_id = dof_object_id;
    pointinfo.offset = 0;
    _processor_to_pointInfoVec[pid].push_back(pointinfo);
  }
}

void
MultiAppGeneralFieldTransfer::extractOutgoingPoints(const VariableName & var_name,
                                                    ProcessorToPointVec & outgoing_points)
{
  // Clean up to blocks that were cached
  _to_blocks.clear();
  // Clean up the map from processor to pointInfo vector
  // This map shuld be consistent with outgoing_points
  _processor_to_pointInfoVec.clear();
  // Loop over all problems
  for (unsigned int i_to = 0; i_to < _to_problems.size(); ++i_to)
  {
    // libMesh EquationSystems
    auto & es = _to_problems[i_to]->es();
    // libMesh system that has this variable
    // Assume var name is unique in an equation system
    System * to_sys = find_sys(es, var_name);
    auto sys_num = to_sys->number();
    auto var_num = to_sys->variable_number(var_name);
    // libMesh MeshBase
    auto & to_mesh = to_sys->get_mesh();
    auto & fe_type = to_sys->variable_type(var_num);
    // FEM type info
    bool is_nodal = fe_type.family == LAGRANGE;

    // Moose mesh
    MooseMesh * to_moose_mesh = &_to_problems[i_to]->mesh();

    // Take users' input block names
    // Change them to ids
    // Store then in a member variables
    if (isParamValid("to_blocks"))
    {
      // User input block names
      auto & blocks = getParam<std::vector<SubdomainName>>("to_blocks");
      // Subdomain ids
      std::vector<SubdomainID> ids = to_moose_mesh->getSubdomainIDs(blocks);
      // Store these ids
      _to_blocks.insert(ids.begin(), ids.end());
    }

    // We support more general variables via libMesh GenericProjector
    if (fe_type.order > CONSTANT && !is_nodal)
    {
      RecordRequests<Number> f;
      RecordRequests<Gradient> g;
      NullAction<Number> nullsetter;
      std::vector<unsigned int> varvec(1, var_num);

      libMesh::GenericProjector<RecordRequests<Number>,
                                RecordRequests<Gradient>,
                                Number, NullAction<Number>>
        request_gather(*to_sys, f, &g, nullsetter, varvec);


      ConstElemRange active_local_elem_range
        (to_mesh.active_local_elements_begin(),
         to_mesh.active_local_elements_end());

      request_gather.project(active_local_elem_range);

      for (Point p : f.points_requested())
        {
          // using dof_object_id 0 for value requests
          this->cacheOutgoingPointInfor(p, 0, i_to, outgoing_points);
        }

      // This is going to require more complicated transfer work
      if (!g.points_requested().empty())
        {
          mooseError("We don't currently support variables with gradient degrees of freedom");
        }
    }
    else if (is_nodal)
    {
      for (const auto & node : to_mesh.local_node_ptr_range())
      {
        // Skip this node if the variable has no dofs at it.
        if (node->n_dofs(sys_num, var_num) < 1)
          continue;

        // Skip if it is a block restricted transfer and current node does not have
        // specified blocks
        if (blockRestrictedTarget() && !hasBlocks(_to_blocks, to_moose_mesh, node))
          continue;

        // Cache point information
        // We will use this information later for setting values back to solution vectors
        cacheOutgoingPointInfor(*node + _to_positions[i_to], node->id(), i_to, outgoing_points);
      }
    }
    else // Elemental
    {
      for (auto & elem : as_range(to_mesh.local_elements_begin(), to_mesh.local_elements_end()))
      {
        // Skip this element if the variable has no dofs at it.
        if (elem->n_dofs(sys_num, var_num) < 1)
          continue;

        // Skip if it is a block restricted block and current elem does not have
        // specified blocks
        if (blockRestrictedTarget() && !hasBlocks(_to_blocks, elem))
          continue;

        // Cache point information
        // We will use this information later for setting values back to solution vectors
        cacheOutgoingPointInfor(
            elem->centroid() + _to_positions[i_to], elem->id(), i_to, outgoing_points);
      } // for
    }   // else
  }     // for
}

void
MultiAppGeneralFieldTransfer::extractLocalFromBoundingBoxes(std::vector<BoundingBox> & local_bboxes)
{
  local_bboxes.resize(_froms_per_proc[processor_id()]);
  // Find the index to the first of this processor's local bounding boxes.
  unsigned int local_start = 0;
  for (processor_id_type i_proc = 0; i_proc < n_processors() && i_proc != processor_id(); ++i_proc)
  {
    local_start += _froms_per_proc[i_proc];
  }

  // Extract the local bounding boxes.
  for (unsigned int i_from = 0; i_from < _froms_per_proc[processor_id()]; ++i_from)
  {
    local_bboxes[i_from] = _bboxes[local_start + i_from];
  }
}

void
MultiAppGeneralFieldTransfer::buildMeshFunctions(
    const VariableName & var_name, std::vector<std::shared_ptr<MeshFunction>> & local_meshfuns)
{
  // Construct a local mesh for each problem
  for (unsigned int i_from = 0; i_from < _from_problems.size(); ++i_from)
  {
    FEProblemBase & from_problem = *_from_problems[i_from];
    MooseVariableFEBase & from_var = from_problem.getVariable(
        0, var_name, Moose::VarKindType::VAR_ANY, Moose::VarFieldType::VAR_FIELD_STANDARD);

    System & from_sys = from_var.sys().system();
    unsigned int from_var_num = from_sys.variable_number(from_var.name());

    std::shared_ptr<MeshFunction> from_func;
    from_func.reset(new MeshFunction(
        from_problem.es(), *from_sys.current_local_solution, from_sys.get_dof_map(), from_var_num));
    from_func->init();
    from_func->enable_out_of_mesh_mode(OutOfMeshValue);
    local_meshfuns.push_back(from_func);
  }
}

void
MultiAppGeneralFieldTransfer::evaluateInterpValues(
    const std::vector<BoundingBox> & local_bboxes,
    const std::vector<std::shared_ptr<MeshFunction>> & local_meshfuns,
    const std::vector<Point> & incoming_points,
    std::vector<Real> & outgoing_vals)
{
  dof_id_type i_pt = 0;
  for (auto & pt : incoming_points)
  {
    // Loop until we've found the lowest-ranked app that actually contains
    // the quadrature point.
    for (MooseIndex(_from_problems.size()) i_from = 0;
         i_from < _from_problems.size() && outgoing_vals[i_pt] == OutOfMeshValue;
         ++i_from)
    {
      if (local_bboxes[i_from].contains_point(pt))
      {
        // Use mesh funciton to compute interpolation values
        auto val = (*local_meshfuns[i_from])(pt - _from_positions[i_from]);
        // Assign value
        outgoing_vals[i_pt] = val;
      }
    }

    // Move to next point
    i_pt++;
  }
}

void
MultiAppGeneralFieldTransfer::cacheIncomingInterpVals(
    processor_id_type pid,
    const VariableName & var_name,
    std::vector<PointInfo> & pointInfoVec,
    const std::vector<Point> & point_requests,
    const std::vector<Real> & incoming_vals,
    DofobjectToInterpValVec & dofobject_to_valsvec,
    InterpCaches & interp_caches)
{
  mooseAssert(pointInfoVec.size() == incoming_vals.size(),
              " Number of dof objects does not equal to the number of incoming values");

  dof_id_type val_offset = 0;
  for (auto & pointinfo : pointInfoVec)
  {
    const auto problem_id = pointinfo.problem_id;
    const auto dof_object_id = pointinfo.dof_object_id;

    const std::pair<unsigned int, dof_id_type> dofobject(problem_id, dof_object_id);

    // libMesh EquationSystems
    auto & es = _to_problems[problem_id]->es();
    // libMesh system
    System * to_sys = find_sys(es, var_name);

    // libMesh mesh
    MeshBase & to_mesh = _to_meshes[problem_id]->getMesh();
    auto var_num = to_sys->variable_number(var_name);
    auto sys_num = to_sys->number();
    auto & fe_type = to_sys->variable_type(var_num);
    bool is_nodal = fe_type.family == LAGRANGE;

    if (fe_type.order > CONSTANT && !is_nodal)
    {
      InterpCache & cache = interp_caches[problem_id];
      Point p = point_requests[val_offset];
      // We should only have one value for each variable at any given point.
      libmesh_assert(cache.count(p) == 0);
      cache[p] = incoming_vals[val_offset];
    }
    else
    {
      // Use this dof object pointer, so we can handle
      // both element and node using the same code
      DofObject * dof_object_ptr = nullptr;
      // It is a node
      if (is_nodal)
        dof_object_ptr = to_mesh.node_ptr(dof_object_id);
      // It is an element
      else
        dof_object_ptr = to_mesh.elem_ptr(dof_object_id);

      // We should only be supporting nodal and constant elemental
      // variables in this code path; if we see multiple DoFs on one
      // object we should have been using GenericProjector
      mooseAssert(dof_object_ptr->n_dofs(sys_num, var_num) == 1,
                  "Unexpectedly found " <<
                  dof_object_ptr->n_dofs(sys_num, var_num) <<
                  "dofs instead of 1");

      auto & dofobject_to_val = dofobject_to_valsvec[problem_id];

      // Check if we visited this dof object ealier
      auto values_ptr = dofobject_to_val.find(dof_object_id);
      // We did not visit this
      if (values_ptr == dofobject_to_val.end())
      {
        // Values for this dof object
        auto & val = dofobject_to_val[dof_object_id];
        // Interpolation value
        val.first = incoming_vals[val_offset];
        // Where this value came from
        val.second = pid;
      }
      else
      {
        auto & val = values_ptr->second;
        // We adopt values from the smallest rank which has a valid value
        if ((val.second > pid || val.first == OutOfMeshValue) &&
            incoming_vals[val_offset] != OutOfMeshValue)
          {
            val.first = incoming_vals[val_offset];
            val.second = pid;
          }
      }
    }

    // Move it to next position
    val_offset++;
  }
}

void
MultiAppGeneralFieldTransfer::setSolutionVectorValues(
    const VariableName & var_name,
    const DofobjectToInterpValVec & dofobject_to_valsvec,
    const InterpCaches & interp_caches)
{
  for (unsigned int problem_id = 0; problem_id < _to_problems.size(); ++problem_id)
  {
    auto & dofobject_to_val = dofobject_to_valsvec[problem_id];

    // libMesh EquationSystems
    auto & es = _to_problems[problem_id]->es();

    // libMesh system
    System * to_sys = find_sys(es, var_name);

    // libMesh mesh
    MeshBase & to_mesh = _to_meshes[problem_id]->getMesh();
    auto var_num = to_sys->variable_number(var_name);
    auto sys_num = to_sys->number();

    auto & fe_type = to_sys->variable_type(var_num);
    bool is_nodal = fe_type.family == LAGRANGE;

    if (fe_type.order > CONSTANT && !is_nodal)
    {
    }
    else
    {
      for (auto & val_pair : dofobject_to_val)
      {
        auto dof_object_id = val_pair.first;

        DofObject * dof_object = nullptr;
        if (is_nodal)
          dof_object = to_mesh.node_ptr(dof_object_id);
        else
          dof_object = to_mesh.elem_ptr(dof_object_id);

        auto dof = dof_object->dof_number(sys_num, var_num, 0);

        auto val = val_pair.second.first;

        // This will happen if meshes are mismatched
        if (_error_on_miss && val == OutOfMeshValue)
        {
          if (is_nodal)
            mooseError("Node ", dof_object_id, " for app ", problem_id, " could not be located ");
          else
            mooseError("Element ", dof_object_id, " for app ", problem_id, " could not be located ");
        }

        // We should not put garbage into solution vector
        if (val == OutOfMeshValue)
          continue;

        to_sys->solution->set(dof, val);
      }
    }

    to_sys->solution->close();
    // Sync local solutions
    to_sys->update();
  }
}

bool
MultiAppGeneralFieldTransfer::blockRestrictedTarget() const
{
  return !_to_blocks.empty();
}

bool
MultiAppGeneralFieldTransfer::blockRestrictedSource() const
{
  return !_from_blocks.empty();
}

bool
MultiAppGeneralFieldTransfer::hasBlocks(std::set<SubdomainID> & blocks, const Elem * elem) const
{
  return blocks.find(elem->subdomain_id()) != blocks.end();
}

bool
MultiAppGeneralFieldTransfer::hasBlocks(std::set<SubdomainID> & blocks,
                                        const MooseMesh * mesh,
                                        const Node * node) const
{
  const std::set<SubdomainID> & node_blocks = mesh->getNodeBlockIds(*node);
  std::set<SubdomainID> u;
  std::set_intersection(blocks.begin(),
                        blocks.end(),
                        node_blocks.begin(),
                        node_blocks.end(),
                        std::inserter(u, u.begin()));
  return !u.empty();
}
